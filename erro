# main_app.py (or whatever you call your main entry point)
from agents.input_agent import input_agent
from agents.intent_agent import intent_agent
from langgraph.graph import StateGraph, END
from langgraph.checkpoint.memory import MemorySaver
from typing import List, Literal, TypedDict, Annotated
import operator
import uuid
from utils.config import logger
import asyncio
from pyvegas.langx.checkpointer import AsyncVegasSaver

# Optional: For local development, load environment variables from a .env file
from dotenv import load_dotenv
load_dotenv()


# State Schema - IMPORTANT: Use the AgentState from utils.types for consistency
# If you want to keep this definition here, ensure it's identical to utils.types.AgentState
# and comment out or remove the import from utils.types in this file.
# For now, I'll assume you want to keep this definition here for self-containment.
class InputAgentState(TypedDict):
    dialog: Annotated[List[str], operator.add]
    last_input: str
    status: Literal["complete", "incomplete"]
    final_problem_statement: str
    messages: Annotated[List[dict], operator.add]
    # Add other fields that might be used by input/intent agents, if not already in utils.types
    flow_type: str
    documentation: List[str]
    next_question: str
    thread_id: str
    source:str


async def build_input_intent_graph():
    """
    Defines and compiles the LangGraph for the input and intent conversation flow.
    """
    try:
        # Define the graph
        graph = StateGraph(InputAgentState)

        # Define nodes
        graph.add_node("input", input_agent)
        graph.add_node("intent", intent_agent)

        # Entry point
        graph.set_entry_point("input")

        graph.add_conditional_edges(
            "input",
            lambda s: "intent" if s.get("status") == "complete" else "input",
            {
                "input": "input",
                "intent": "intent"
            }
        )

        # Define the edge from 'intent' to END
        graph.add_edge("intent", END)

        # Compile the app with a checkpointer for state persistence
        app = graph.compile(checkpointer=MemorySaver())
        logger.info("LangGraph conversation app compiled successfully.")
        return app
    except Exception as e:
        logger.error(f"something went wrong inside build_input_intent_graph: {e}", exc_info=True)
        raise # Re-raise to ensure main knows about the failure

async def run_input_intent_agent_server(input):
    
    async with AsyncVegasSaver.execute() as checkpointer:

        """
        Runs the interactive console chat loop with the provided LangGraph app.
        """
        try:
            current_session_state = {
                "last_input": "",
                "thread_id": "",
                "dialog": [],
                "messages": []
            }

            # Define the graph
            graph = StateGraph(InputAgentState)

            # Add nodes
            graph.add_node("input", input_agent)
            graph.add_node("intent", intent_agent)

            # Set entry point
            graph.set_entry_point("input")

            # Add conditional logic
            graph.add_conditional_edges(
                "input",
                lambda s: "intent" if s.get("status") == "complete" else END,
                {
                    "intent": "intent",
                    END: END
                }
            )
            graph.add_edge("intent", END)

            # Compile app
            app = graph.compile(checkpointer=checkpointer)
            logger.info("LangGraph app compiled successfully.")

            user_input = input.user_query
            thread_id = input.thread_id.strip() if input.thread_id and input.thread_id.strip() else str(uuid.uuid4())

            if input.thread_id:
                logger.info(f"--- Resuming session (thread_id: {thread_id})")
            else:
                logger.info(f"--- Starting new session (thread_id: {thread_id})")

            # state_data = None

            # try:
            #     # Try getting the tuple (id, state)
            #     state_tuple = await checkpointer.aget_tuple(thread_id)

            #     if state_tuple:
            #         print("Previous state tuple found:", state_tuple)
            #         _, state_json = state_tuple

            #         # Parse the JSON string into a dict
            #         import json
            #         state_data = json.loads(state_json)
            #         print("Parsed state data:", state_data)
            #     else:
            #         print("No saved state for this thread_id.")
            #         state_data = None

            # except Exception as e:
            #     logger.error(f"Error retrieving previous state: {e}", exc_info=True)
            #     state_data = None

            # if state_data:
            #     print(f"Restored previous session state")
            #     current_session_state = state_data
            # else:
            #     print("No valid previous state found for this thread_id. Starting fresh.")
            #     current_session_state = {
            #         "last_input": "",
            #         "thread_id": "",
            #         "dialog": [],
            #         "messages": []
            #     }

            # Update session with current input

            current_session_state["last_input"] = user_input
            current_session_state["thread_id"] = thread_id
            current_session_state["messages"].append({"role": "user", "content": user_input})

            try:
                result = await app.ainvoke(current_session_state, config={"configurable": {"thread_id": thread_id}})
                logger.info(f"Execution result: {result}")
                return result
            except Exception as run_error:
                logger.error(f"LangGraph invocation failed: {run_error}", exc_info=True)
                return {
                    "status": "error",
                    "message": str(run_error),
                    "thread_id": thread_id,
                    "dialog": current_session_state.get("dialog", []),
                    "final_problem_statement": [],
                    "next_question": "Something went wrong. Please try again."
                }

        except Exception as e:
            logger.error(f"run_input_intent_agent_server crashed: {e}", exc_info=True)
            return {
                "status": "error",
                "message": str(e),
                "thread_id": "",
                "dialog": [],
                "final_problem_statement": [],
                "next_question": "An unexpected error occurred. Please restart the conversation."
            }

async def run_input_intent_agent(app):
    """
    Runs the interactive console chat loop with the provided LangGraph app.
    """
    try:
        # Removed: Check for GOOGLE_API_KEY environment variable here.
        # The LLM initialization in utils/config.py will handle its absence.

        # Generate a unique thread ID for this conversation session
        thread_id = str(uuid.uuid4())
        print(f"--- Starting new conversation session (ID: {thread_id}). Type 'exit' to end.")

        # Initialize the state for the *first* turn of this session
        current_session_state = InputAgentState(
            dialog=[],
            last_input="",
            status="incomplete",
            final_problem_statement="",
            messages=[],
            flow_type="",
            documentation=[],
            next_question=""
        )
        
        while True:
            # Check if the task is completed based on the final state from the previous turn
            if current_session_state.get("status") == "complete":
                print("âœ… Task completed.\n")
                # To start a new conversation after completion, uncomment the lines below:
                # thread_id = str(uuid.uuid4())
                # current_session_state = InputAgentState(dialog=[], last_input="", status="incomplete", final_problem_statement="", messages=[], flow_type="", documentation=[], next_question="")
                # print(f"Starting new conversation session (ID: {thread_id}).")
                break # Exit the loop after completion

            # If status is incomplete and there's a next_question, print it
            if current_session_state.get("status") == "incomplete" and current_session_state.get("next_question"):
                print(f"\nAgent: {current_session_state['next_question']}")
            # For the very first turn, next_question might be empty, but the prompt in input_agent
            # should generate the initial greeting.

            user_input = input("You: ").strip()
            if user_input.lower() in {"exit", "quit"}:
                print("Exiting conversation. Goodbye!")
                break

            # Update the state with the new user input for the current turn.
            current_session_state["last_input"] = user_input
            current_session_state["dialog"].append(user_input)
            
            # Ensure 'messages' list exists and append user message for LLM context
            if "messages" not in current_session_state or current_session_state["messages"] is None:
                current_session_state["messages"] = []
            current_session_state["messages"].append({"role": "user", "content": user_input})

            # Invoke the LangGraph app with the updated current state and thread_id
            # This will run one or more nodes until a conditional edge leads to END or a loop.
            result = await app.ainvoke(current_session_state, config={"configurable": {"thread_id": thread_id}})

            # Update our `current_session_state` with the final state from this invocation.
            current_session_state = result

            print("result::::",result)
            return result

    except Exception as e:
        logger.error(f"something went wrong inside run_input_intent_agent: {e}", exc_info=True)
        print(f"\nAgent: An unexpected error occurred: {e}. Please restart the conversation.")
        # Decide how to handle the state on a critical error (e.g., reset, save for debugging)
        # For now, just print and let the loop potentially continue or exit.

async def input_intent_main():
    """Main entry point for the local interactive application."""
    print("running run_input_intent_agent locally...")
    print("building the graph...")
    app = await build_input_intent_graph() # Await the graph building
    print("Going to have a conversation with input agent....")
    result = await run_input_intent_agent(app) # Await the interactive chat function
    print("final result::::",result)
    return result

async def input_intent_server(input):
    result = await run_input_intent_agent_server(input) # Await the interactive chat function
    print("final result::::",result)
    return result

if __name__ == "__main__":
    asyncio.run(input_intent_main())

