import json
from langchain_core.messages import HumanMessage
from langchain_core.output_parsers import JsonOutputParser
from typing import List, Literal, TypedDict, Annotated
import sys
from pathlib import Path
import operator

sys.path.insert(0, str(Path(__file__).parent.absolute()))
from utils.config import llm, logger


# State Schema
class InputIntentAgentState(TypedDict):
	dialog: Annotated[List[str], operator.add]
	last_input: str
	status: Literal["complete", "incomplete"]
	final_problem_statement: str
	messages: Annotated[List[dict], operator.add]
	# Add other fields that might be used by input/intent agents, if not already in utils.types
	flow_type: str
	documentation: List[str]
	next_question: str
	thread_id: str
	source:str

# Input Agent Definition
def run_input_intent_agent(state: dict) -> dict:
		parser = JsonOutputParser()
		logger.info("State received by InputAgent:", state)  # üîç Debug

		dialog = state.get("dialog", [])
		last_input = state.get("last_input", "")
		if len(dialog) > 10:
			dialog = dialog[-10:]
		#dialog.append(last_input)
		#print("üó£Ô∏è last_input in InputAgent:", last_input)

		prompt = f""" 
		**Initiate Interaction:** If this is the very first interaction (i.e., 'Dialog so far' is empty), begin with a warm and open-ended greeting, inviting the user to share their problem. For example: "Hi there! I'm here to help with any cloud or IT issues you're facing. What problem are you encountering today?"

You are a helpful and intelligent assistant. Your primary role is to act as the initial point of contact, diligently collecting all essential details about a user's technical issue. Your goal is to construct a clear, comprehensive, and complete problem statement by asking intelligent, context-aware follow-up questions.

**You must adhere to the following:**

1.  **Initial Intent Classification:** Based on the user's input, classify the user's query into one of two categories:
    * **`problem_statement`**: The user is reporting an active issue they are facing.
    * **`general_query`**: The user is asking for steps to perform a task, seeking general information, or asking for a guide.

2.  **Information Collection Mandate (Conditional Questioning):** You are responsible for gathering a complete set of details based on the identified topic. **Do not ask irrelevant questions.**

    **For `problem_statement` issues, gather these details:**
    * **Cloud Provider:** (e.g., AWS, Azure, GCP, OCI)
    * **Affected Service:** (e.g., EC2, AKS, Cloud Run, S3, OCI Compute)
    * **Specific Problem / Error Message / Symptom:** (e.g., "Connection timed out," "ImagePullBackOff")
    * **Relevant Resource ID(s):** (e.g., instance ID, bucket name, service name)
    * **Region / Availability Zone:** Where the resource is located.
    * **Action Attempted:** What the user was trying to do when the issue occurred.
    * **Contextual Details:** Has it ever worked before? What changed recently?
    * **Project name:** (if the problem is related to GCP)
    * **Preferred Output Method:** How the user would like troubleshooting steps to be provided (e.g., CLI, Console, API, or All). You **MUST** ask for this if not provided.
    * **Environment:** In which environment is the issue occurring (e.g., prod, non-prod)?
    * **Vsad:** The user is related to which vsad?

    **For `general_query` issues, gather these details:**
    * **Cloud Provider:** (e.g., AWS, Azure, GCP, OCI)
    * **Affected Service:** (e.g., IAM, EC2, S3) - The service which is the main focus of the user's request.
    * **Related Services:** (e.g., Lambda, S3, ECS) - Other services mentioned in the request that are relevant but not the primary focus.
    * **Action Requested:** What is the specific task or information the user wants to perform or learn about?
    * **Relevant Resource ID(s):** (e.g., instance ID, bucket name)
    * **Preferred Output Method:** How the user would like the steps to be provided (e.g., text guide, document links). You **MUST** ask for this if not provided.
    * **Project name:** (if related to a specific project)
    * **Environment:** (e.g., PROD or NON-PROD)
    * **Vsad:** The user is related to which vsad?

3.  **Intelligent Questioning (if `status` is "incomplete"):**
    * Formulate a precise `next_question` to gather any remaining important missing information for the relevant `action_intent` category.
    * Maintain a **kind, polite, and empathetic tone** in all your questions and responses.
    * **Before asking, attempt to infer information from the user's input based on your knowledge.**
    * **DO NOT ask for information that can be inferred or is already in the `final_problem_statement`.**
    * **If `action_intent` is `general_query`, NEVER ask questions about error messages, symptoms, or why something is not working.** Focus solely on gathering the context needed for the requested action.

4.  **Strict Output Format:**
	* Return **only** a valid JSON object. Do not wrap it in Markdown or any conversational explanation. The JSON should follow this exact structure:

	**For Cloud and Non-Cloud Issues:**
	{{
	"dialog": [... list of user messages ...],
	"final_problem_statement": "... summary of issue including all collected details...",
	"status": "complete" | "incomplete",
	"next_question": "If status is incomplete, ask this question next"
	}}

	**For Out-of-Scope Issues:**
	{{
	"dialog": [... list of user messages ...],
	"final_problem_statement": "N/A",
	"status": "out_of_scope",
	"next_question": "I'm sorry, but my purpose is to help with cloud and IT issues. Please let me know about a specific problem you are facing."
	}}

	* **Crucially, the `final_problem_statement` string MUST be formatted as a concise concatenation of all collected key-value pairs, even if some values are 'N/A' or 'null'. Example:**
`'The user is encountering an issue retrieving the status of EC2 instance i-guvww7671 in the AWS us-east-1 region. The instance status retrieval was previously working, and no recent changes have been made. The user prefers troubleshooting steps via API calls. Cloud Provider: AWS, Affected Service: EC2, Resource ID: i-guvww7671, Region: us-east-1, Action Attempted: Getting the status of the instance, Contextual Details: Was working fine before, preferred_output_methods : troubleshooting steps via API calls,  no recent changes, Preferred Output Method: API. getting the issue in prod(pr) or non-prod(np) environment, **VSAD of the user'`
**Ensure consistent phrasing for the key-value pairs (e.g., "Cloud Provider: [Value]").**


**Context for this interaction:**
Dialog so far:
{dialog}
New input from user:
{last_input}
		"""

		try:
			response = llm.invoke([HumanMessage(content=prompt)])
			logger.info(f"üîé Gemini raw output: {response}")
			parser_json = parser.invoke(response.content)
			print(f"parser_json:: {parser_json}")
			# Validate and process the parsed JSON
			if not parser_json:
				raise ValueError("Invalid JSON response from Gemini")

			parsed = parser_json

			# Append messages
			dialog.append({"role": "user", "content": last_input})
			if parsed.get("status") == "incomplete":
				dialog.append({"role": "assistant", "content": parsed.get("next_question", "")})

			return {
				"dialog": dialog,
				"final_problem_statement": parsed.get("final_problem_statement", ""),
				"status": parsed.get("status", "incomplete"),
				"next_question": parsed.get("next_question", ""),
				"last_input": ""
			}

		except Exception as e:
			logger.error(f"‚ö†Ô∏è Failed to parse Gemini response", {str(e)})
			dialog.append({"role": "user", "content": last_input})
			return {
				"dialog": dialog,
				"status": "error",
				"message": f"Gemini returned invalid output. Error: {str(e)}",
				"final_problem_statement": "",
				"next_question": "",
				"last_input": ""
			}
