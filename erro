    async def generate(self, request: InputRequest):
        try:
            async with AsyncVegasSaver.execute() as checkpointer:
                start_time = time.time()

                # --- Define Graph ---
                graph = StateGraph(InputIntentAgentState)

                # Input agent node
                graph.add_node("input", run_input_intent_agent)

                # Intent agent node
                graph.add_node("intent", run_input_intent_intent_agent)

                # Supervisor node wraps routing logic
                async def run_supervisor(state: dict, config: dict):
                    AGENT_MAP = {
                        "cloud_ops": cloud_ops_agent_runnable,
                        "sysadmin": sysadmin_agent_runnable,
                        "fallback": fallback_agent_runnable,
                        "product_service": product_service_agent_runnable,
                    }

                    supervisor = build_supervisor_agent(
                        state,
                        cloud_ops_agent_runnable,
                        sysadmin_agent_runnable,
                        fallback_agent_runnable,
                        product_service_agent_runnable,
                    )

                    supervisor_state = {
                        "messages": [{
                            "role": "user",
                            "content": (
                                f"Final Problem Statement: {state.get('final_problem_statement')}\n"
                                f"Flow Type: {state.get('flow_type')}\n"
                                f"Documentation: {state.get('documentation')}"
                            )
                        }]
                    }

                    supervisor_output = supervisor.invoke(supervisor_state)
                    logger.info(f"Supervisor output: {supervisor_output}")

                    # Extract agent name
                    if isinstance(supervisor_output, dict) and 'messages' in supervisor_output:
                        last_message = supervisor_output['messages'][-1]
                        agent_name = getattr(last_message, 'content', str(last_message)).strip()
                    else:
                        agent_name = "fallback"

                    # Route to target agent
                    agent_runnable = AGENT_MAP.get(agent_name, fallback_agent_runnable)
                    payload = {"agent_name": agent_name, "body": state}
                    return await agent_runnable.ainvoke(payload)

                graph.add_node("supervisor", run_supervisor)

                # Entry point
                graph.set_entry_point("input")

                # Conditional routing: input â†’ intent OR end
                graph.add_conditional_edges(
                    "input",
                    lambda s: "intent" if s.get("status") == "complete" else END,
                    {"intent": "intent", END: END},
                )

                # Intent always flows to supervisor
                graph.add_edge("intent", "supervisor")
                graph.add_edge("supervisor", END)

                # Compile graph
                app = graph.compile(checkpointer=checkpointer)
                logger.info("LangGraph app compiled successfully.")

                # Thread/session id
                if request.thread_id:
                    thread_id = request.thread_id.strip()
                    logger.info(f"--- Resuming session (thread_id: {thread_id})")
                else:
                    thread_id = str(uuid.uuid4())
                    logger.info(f"--- Starting new session (thread_id: {thread_id})")

                handler = AsyncVegasCallbackHandler(
                    session_id=thread_id,
                    user_id="input-intent-user",
                    metadata={"usecase": self.usecase_name, "context": self.context_name},
                    tags=["langgraph", "multi-agent"],
                )
                config = {"configurable": {"thread_id": thread_id}, "callbacks": [handler]}

                # Restore checkpoint
                full_checkpoint = await checkpointer.aget(config)
                state_data = full_checkpoint['channel_values'] if full_checkpoint else None
                logger.info(f"state_data:: {state_data}")

                # Initialize state
                if not state_data:
                    current_state = InputIntentAgentState(
                        dialog=[],
                        last_input=request.user_query,
                        final_problem_statement="",
                        flow_type="",
                        documentation=[],
                        thread_id=thread_id,
                        source="",
                    )
                else:
                    current_state = state_data
                    current_state["last_input"] = request.user_query

                # --- Run the graph ---
                final_state = await app.ainvoke(current_state, config=config)
                logger.info(f"final_state::{final_state}")

                return final_state, {}

        except Exception as e:
            logger.error(f"LangGraph invocation or state retrieval failed: {e}", exc_info=True)
            response = {
                "error": f"An unexpected error occurred: {str(e)}",
                "processing_time": time.time() - start_time
            }
            return response, {}
