import asyncio
import os
import time
import uuid
from typing import Any

# PyVegas imports
"""
WorkflowService: Combines Input Agent and Intent Agent using LangGraph.

This service orchestrates the agent workflow, manages session state,
and handles requests/responses for the input_intent use case.
"""
from pyvegas.core import get_settings
from pyvegas.langx.callback import AsyncVegasCallbackHandler
from pyvegas.langx.checkpointer import AsyncVegasSaver
from pyvegas.serve.base import BaseService
from pyvegas.serve.base.models import PyVegasBaseRequest, PyVegasBaseResponse

# LangGraph and LangChain imports
from langgraph.graph import StateGraph, END

# Pydantic imports
from pydantic import Field

# Optional: Load environment variables
from dotenv import load_dotenv
load_dotenv()

# --- Configuration and Logging ---
#logger = get_logger(__name__)
settings = get_settings()

import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.absolute()))

from agents.input import run_input_intent_agent, InputIntentAgentState
from agents.intent import run_input_intent_intent_agent
from agents.supervisor import build_supervisor_agent
from agents.cloud_ops import cloud_ops_agent_runnable
from agents.sysadmin import sysadmin_agent_runnable
from agents.fallback import fallback_agent_runnable
from agents.product_service import product_service_agent_runnable
from utils.config import logger
from .models import InputRequest, InputResponse

# --- Main Service Class ---
class WorkflowService(BaseService):
    """
    Main service class for the InputIntent agent.

    Initializes configuration, validates environment, and defines the
    agent graph logic for processing user queries and generating responses.
    """

    def __init__(self) -> None:
        """Initialize the InputIntent agent service."""
        logger.info("Initializing WorkflowService")

        # Get configuration from environment variables or settings
        self.usecase_name = os.getenv("USECASE_NAME") or getattr(settings, "USECASE_NAME", None)
        self.context_name = os.getenv("CONTEXT_NAME") or getattr(settings, "CONTEXT_NAME", None)
        self.environment = os.getenv("ENVIRONMENT", None) or getattr(settings, "ENVIRONMENT", None)

        # Validate usecase_name and context_name
        if not self.usecase_name or not self.context_name:
            raise ValueError(
                f"USECASE_NAME or CONTEXT_NAME not set. "
                f"Check - {__file__}:{__import__('inspect').currentframe().f_lineno}. "
                "Please set USECASE_NAME and CONTEXT_NAME as environment variables or in your settings to start the service."
            )

        logger.info(
            f"WorkflowService initialized with usecase={self.usecase_name}, context={self.context_name}"  # noqa: E501
        )

    @classmethod
    def get_request_model(cls):
        return InputRequest

    @classmethod
    def get_response_model(cls):
        return InputResponse

    async def generate(self, request: InputRequest):
        try:
            async with AsyncVegasSaver.execute() as checkpointer:
                start_time = time.time()

                # Define the graph
                graph = StateGraph(InputIntentAgentState)

                # Add nodes
                graph.add_node("input", run_input_intent_agent)
                graph.add_node("intent", run_input_intent_intent_agent)

                # Set entry point
                graph.set_entry_point("input")

                # Add conditional logic
                graph.add_conditional_edges(
                    "input",
                    lambda s: "intent" if s.get("status") == "complete" else END,
                    {
                        "intent": "intent",
                        END: END
                    }
                )
                graph.add_edge("intent", END)

                # Compile app
                app = graph.compile(checkpointer=checkpointer)
                logger.info("LangGraph app compiled successfully.")

                if request.thread_id:
                    thread_id = request.thread_id.strip()
                    logger.info(f"--- Resuming session (thread_id: {thread_id})")
                else:
                    thread_id = str(uuid.uuid4())
                    logger.info(f"--- Starting new session (thread_id: {thread_id})")

                handler = AsyncVegasCallbackHandler(
                    session_id=thread_id,
                    user_id="input-intent-user",
                    metadata={"usecase": self.usecase_name, "context": self.context_name},
                    tags=["langgraph", "multi-agent"],
                )
                config = {"configurable": {"thread_id": thread_id}, "callbacks": [handler]}

                full_checkpoint = await checkpointer.aget(config)
                state_data = full_checkpoint['channel_values'] if full_checkpoint else None
                logger.info(f"state_data:: {state_data}")

                if not state_data:
                    current_state = InputIntentAgentState(
                        dialog=[],
                        last_input=request.user_query,
                        final_problem_statement="",
                        flow_type="",
                        documentation=[],
                        thread_id=thread_id,
                        source="",
                    )
                else:
                    current_state = state_data
                    current_state["last_input"] = request.user_query

                # Run input and intent agents
                final_state = await app.ainvoke(current_state, config=config)
                logger.info(f"final_state::{final_state}")

                # Supervisor invocation logic
                AGENT_MAP = {
                    "cloud_ops": cloud_ops_agent_runnable,
                    "sysadmin": sysadmin_agent_runnable,
                    "fallback": fallback_agent_runnable,
                    "product_service": product_service_agent_runnable
                }

                supervisor = build_supervisor_agent(
                    final_state,
                    cloud_ops_agent_runnable,
                    sysadmin_agent_runnable,
                    fallback_agent_runnable,
                    product_service_agent_runnable
                )
                logger.info(f"Supervisor agent built: {type(supervisor)}")

                if hasattr(supervisor, 'get_graph'):
                    graph_info = supervisor.get_graph()
                    logger.info(f"Graph structure: {graph_info}")

                # Transform InputRequest to the expected state format for LangGraph
                supervisor_state = {
                    "messages": [{
                        "role": "user",
                        "content": f"Final Problem Statement: {final_state.get('final_problem_statement')}\nFlow Type: {final_state.get('flow_type')}\nDocumentation: {final_state.get('documentation')}"
                    }]
                }

                logger.info(f"About to invoke supervisor with transformed state: {supervisor_state}")

                supervisor_output = supervisor.invoke(supervisor_state)

                logger.info(f"Supervisor output: {supervisor_output}")

                # Extract agent name from supervisor output
                if isinstance(supervisor_output, dict) and 'messages' in supervisor_output:
                    last_message = supervisor_output['messages'][-1]
                    if hasattr(last_message, 'content'):
                        agent_name = last_message.content.strip()
                    else:
                        agent_name = str(last_message).strip()
                else:
                    logger.error(f"Unexpected supervisor output format: {supervisor_output}")
                    raise ValueError(f"Supervisor returned unexpected format: {type(supervisor_output)}")

                logger.info(f">>> Supervisor routing to agent: {agent_name}")

                agent_runnable = AGENT_MAP.get(agent_name)
                if not agent_runnable:
                    logger.warning(f"Agent '{agent_name}' not found in AGENT_MAP, using fallback")
                    agent_name = "fallback"
                    agent_runnable = AGENT_MAP.get(agent_name)

                payload = {
                    "agent_name": agent_name,
                    "body": final_state
                }
                final_agent_state = await agent_runnable.ainvoke(payload)

                #status = final_agent_state.get('status', 'incomplete')

                return final_agent_state, {}

        except Exception as e:
            logger.error(f"LangGraph invocation or state retrieval failed: {e}", exc_info=True)
            response = {
                "error": f"An unexpected error occurred: {str(e)}",
                "processing_time": time.time() - start_time
            }
            return response, {}

# #For local testing
# if __name__ == "__main__":
#     async def main() -> None:
#         service = WorkflowService()
#         test_query = "What is the weather in Paris?"
#         request = InputRequest(user_query=test_query,thread_id="")
#         response, _ = await service.generate(request)
#         print("Response:", response.response)
#         print("Reasoning:", response.reasoning)
