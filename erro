import json
import re

# Install dependencies if needed:
# pip install lxml

from lxml import etree
from lxml.html import builder as E

def clean_llm_json_response(llm_resp: str) -> dict:
    # Remove code block if present (e.g., ```json\n...\n```)
    cleaned = re.sub(r"^```json\n|```$", "", llm_resp.strip(), flags=re.MULTILINE | re.DOTALL)
    return json.loads(cleaned)

def json_to_confluence_xhtml(data: dict) -> str:
    div = E.DIV()
    for section in data.get("sections", []):
        div.append(E.H2(section["title"]))
        for step in section.get("steps", []):
            div.append(E.P(step["text"]))
            if "code" in step:
                code_block = E.P(E.CODE(step["code"]))
                div.append(code_block)
    return etree.tostring(div, pretty_print=True, method="html", encoding="unicode")

# Async wrapper usage
llm_resp = (await llm.ainvoke(doc_prompt)).content

try:
    parsed_json = clean_llm_json_response(llm_resp)
    llm_response_content = json_to_confluence_xhtml(parsed_json)
except Exception as e:
    print("Error parsing LLM output:", e)
    llm_response_content = "No summary found."

# Continue your pipeline
identified_cloud = (await llm.ainvoke(cloud_provider_prompt)).content.strip()
summarized_text = "No summary found."

if state.get("destination_page_title"):
    identified_cloud = state.get("destination_page_title")

result = {
    "summarized_content": llm_response_content or summarized_text,
    "identified_cloud_provider": identified_cloud,
    "mcp_tools": mcp_tools_instance
}

print("result:::::::::::::::::::::::", result)
return result
