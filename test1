from typing import Annotated, TypedDict
from langgraph.graph import StateGraph, END
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage, ToolMessage
import operator
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.tools import tool
from langgraph_supervisor import create_supervisor
from langgraph.prebuilt import create_react_agent
import requests
import json
from requests.structures import CaseInsensitiveDict
from langchain_google_genai import ChatGoogleGenerativeAI
import os

# --- API Keys (IMPORTANT: Load from environment variables) ---
RAPIDAPI_KEY = os.environ.get("RAPIDAPI_KEY")
OPENWEATHERMAP_API_KEY = os.environ.get("OPENWEATHERMAP_API_KEY")
GOOGLE_API_KEY = os.environ.get("GOOGLE_API_KEY")

if not RAPIDAPI_KEY:
    raise ValueError("RAPIDAPI_KEY environment variable not set.")
if not OPENWEATHERMAP_API_KEY:
    raise ValueError("OPENWEATHERMAP_API_KEY environment variable not set.")
if not GOOGLE_API_KEY:
    raise ValueError("GOOGLE_API_KEY environment variable not set.")


llm = ChatGoogleGenerativeAI(model="gemini-2.5-flash-preview-05-20", google_api_key=GOOGLE_API_KEY, temperature=0.3) # Increased temperature slightly

# 1. Define the Graph State
class AgentState(TypedDict):
    messages: Annotated[list[BaseMessage], operator.add]


# --- Tools ---
@tool
def get_current_weather(city: str, units: str = "metric") -> str:
    """
    Fetches the current weather conditions for a specified city using OpenWeatherMap.
    Returns temperature, main weather condition, and description.

    Args:
        city (str): The name of the city (e.g., "London", "New York", "Chennai").
        units (str): The unit system for temperature. 'metric' for Celsius (default),
                     'imperial' for Fahrenheit, or 'standard' for Kelvin.
    """
    base_url = "https://api.openweathermap.org/data/2.5/weather"
    params = {
        "q": city,
        "units": units,
        "appid": OPENWEATHERMAP_API_KEY
    }
    try:
        response = requests.get(base_url, params=params, timeout=10)
        response.raise_for_status()
        data = response.json()

        if data.get("cod") == 200:
            main_data = data.get("main", {})
            weather_data = data.get("weather", [{}])[0]
            temp = main_data.get("temp")
            feels_like = main_data.get("feels_like")
            humidity = main_data.get("humidity")
            description = weather_data.get("description")
            main_condition = weather_data.get("main")
            city_name_from_api = data.get("name")

            return (
                f"Current weather in {city_name_from_api}: "
                f"{temp}{unit_symbol} (feels like {feels_like}{unit_symbol}), "
                f"Conditions: {main_condition} - {description}, "
                f"Humidity: {humidity}%."
            )
        else:
            return f"Error from OpenWeatherMap API for {city}: {data.get('message', 'Unknown error')} (Code: {data.get('cod')})"
    except requests.exceptions.HTTPError as e:
        status_code = e.response.status_code
        if status_code == 404:
            return f"City '{city}' not found by OpenWeatherMap. Please check the spelling."
        elif status_code == 401:
            return "OpenWeatherMap API Key is invalid or expired. Please check your key."
        else:
            return f"HTTP error from OpenWeatherMap API for {city}: {status_code} - {e.response.text}"
    except requests.exceptions.ConnectionError as e:
        return f"Connection error to OpenWeatherMap API: {e}. Please check your internet connection."
    except requests.exceptions.Timeout as e:
        return f"Timeout error with OpenWeatherMap API: {e}. The request took too long to respond."
    except json.JSONDecodeError:
        return f"Failed to decode JSON from OpenWeatherMap API response for {city}. Response was: {response.text[:200]}..."
    except Exception as e:
        return f"An unexpected error occurred with OpenWeatherMap API for {city}: {type(e).__name__} - {e}"

@tool
def get_country_detail(country_name: str) -> str:
    """
    Fetches details about a country using the RapidAPI GeoDB API.
    Note: Currently supports only a limited set of countries with hardcoded codes.
    If the input seems like a city, it will suggest that.
    """
    headers = CaseInsensitiveDict()
    headers["x-rapidapi-host"] = "wft-geo-db.p.rapidapi.com"
    headers["x-rapidapi-key"] = RAPIDAPI_KEY

    country_code = {
        "India": "IN", "United States": "US", "United Kingdom": "GB",
        "Canada": "CA", "Australia": "AU", "Germany": "DE",
        "France": "FR", "Japan": "JP", "China": "CN",
        "Brazil": "BR", "South Africa": "ZA", "Mexico": "MX",
        "Spain": "ES", "Italy": "IT", "Russia": "RU",
        "Egypt": "EG", "Argentina": "AR", "South Korea": "KR",
        "New Zealand": "NZ", "Sweden": "SE", "Norway": "NO",
        "Denmark": "DK", "Finland": "FI", "Switzerland": "CH",
        "Netherlands": "NL", "Belgium": "BE", "Austria": "AT",
        "Portugal": "PT", "Greece": "GR", "Turkey": "TR",
        "Saudi Arabia": "SA", "United Arab Emirates": "AE"
    }

    is_likely_city = False
    if len(country_name.split()) == 1 and country_name.lower() not in [k.lower() for k in country_code.keys()]:
        is_likely_city = True

    actual_country_name = next((key for key in country_code if key.lower() == country_name.lower()), None)

    if not actual_country_name:
        if is_likely_city:
            return f"'{country_name}' appears to be a city, not a country. I can only provide details for countries. For example, 'India' or 'United States'."
        else:
            return f"I cannot find country details for '{country_name}'. Please ensure it is a recognized country name from the supported list: {', '.join(country_code.keys())}"


    cntry_name_shrt_code = country_code[actual_country_name]
    url = f"https://wft-geo-db.p.rapidapi.com/v1/geo/countries/{cntry_name_shrt_code}"

    try:
        res = requests.get(url, headers=headers, timeout=10)
        res.raise_for_status()

        data = res.json()["data"]
        callingcode = data.get("callingCode", "N/A")
        currency = data["currencyCodes"][0] if data.get("currencyCodes") else "N/A"
        numberofregion = data.get("numRegions", "N/A")
        flaguri = data.get("flagImageUri", "N/A")

        return (f"The currency in {actual_country_name} is {currency} with calling code {callingcode}, "
                  f"number of regions {numberofregion} and flag image {flaguri}")

    except requests.exceptions.HTTPError as e:
        status_code = e.response.status_code
        if status_code == 404:
            return f"Country '{actual_country_name}' not found by GeoDB API. Please check the spelling or if it's supported."
        elif status_code == 401:
            return "RapidAPI Key is invalid or expired. Please check your key."
        else:
            return f"HTTP error from RapidAPI GeoDB for {actual_country_name}: {status_code} - {e.response.text}"
    except requests.exceptions.ConnectionError as e:
        return f"Connection error to RapidAPI GeoDB: {e}. Please check your internet connection."
    except requests.exceptions.Timeout as e:
        return f"Timeout error with RapidAPI GeoDB: {e}. The request took too long to respond."
    except json.JSONDecodeError:
        return f"Failed to decode JSON from RapidAPI GeoDB API response for {actual_country_name}. Response was: {res.text[:200]}..."
    except KeyError as e:
        return f"Missing expected data in RapidAPI GeoDB response for {actual_country_name}: '{e}' key not found. Response: {res.json()}"
    except Exception as e:
        return f"An unexpected error occurred in get_country_detail for {actual_country_name}: {type(e).__name__} - {e}"


# 2. Create Worker Agents
weather_agent_node = create_react_agent(
    model=llm,
    tools=[get_current_weather],
    prompt=ChatPromptTemplate.from_messages([
        ("system", "You are a helpful weather assistant. Your sole purpose is to provide current weather information using the 'get_current_weather' tool. When asked about weather, use this tool. If the tool call is successful, respond with the weather information. If the tool fails or cannot find the city, clearly state that you couldn't get the weather for the specified location. Never answer questions outside of weather. If the user asks something not related to weather, respond with 'I can only provide current weather information.'"),
        ("human", "{messages}"),
    ]),
    name="weather_agent",
)


country_agent_node = create_react_agent(
    model=llm,
    tools=[get_country_detail],
    prompt=ChatPromptTemplate.from_messages([
        ("system", "You are a helpful country information assistant. Your sole purpose is to provide details about countries using the 'get_country_detail' tool. When asked about a country, use this tool. If the tool call is successful, respond with the country details. If the tool fails or cannot find the country, clearly state that you couldn't get details for the specified country (e.g., 'I couldn't find details for X, it might be a city or not supported.'). Never answer questions outside of country information. If the user asks something not related to countries, respond with 'I can only provide country details.'"),
        ("human", "{messages}"),
    ]),
    name="country_agent",
)


# 3. Create the Supervisor Workflow using create_supervisor
supervisior_agent = create_supervisor(
    agents=[weather_agent_node, country_agent_node],
    model=llm,
    prompt=(
        "You are a highly intelligent and decisive team supervisor. Your task is to accurately direct user queries to the most appropriate specialized agent. "
        "Your decision should be based *solely* on the content of the user's last message. "
        "Here are your instructions:\n\n"
        "1.  **If the user's query clearly asks for current weather information (e.g., 'weather in X', 'temperature in Y', 'how's the weather in Z'), route it to 'weather_agent'.**\n"
        "2.  **If the user's query clearly asks for country information or details (e.g., 'details about X country', 'currency of Y', 'what is the calling code for Z'), route it to 'country_agent'.**\n"
        "3.  **If a specialized agent provides a successful answer and clearly states the information, then you must signal 'FINISH'.**\n"
        "4.  **CRITICAL: If an agent indicates it could not fulfill its task (e.g., 'City not found', 'Country not available', 'appears to be a city', 'error', 'failed to decode', etc.), you MUST relay that specific message directly to the user as your response, and then signal 'FINISH'. Do NOT rephrase, generalize, or provide any other type of response, including greetings or general fallbacks, in this specific scenario.**\n"
        "5.  **For simple greetings like 'Hi', 'Hello', 'Hey', 'Good morning', 'Good evening', etc., respond ONLY with 'Hello! How can I assist you today? I can provide current weather information or country details.' and then signal 'FINISH'.**\n"
        "6.  **For any other query not explicitly covered by the above rules (i.e., not a greeting, weather, or country query), respond ONLY with 'I'm sorry, I can only provide current weather information or country details. Please try asking a question related to those topics.' and then signal 'FINISH'.**\n"
        "Do NOT attempt to answer questions directly. Your only role is to route, provide a specific polite fallback, or relay an agent's specific failure message, and then FINISH."
    ),
)

# Compile the graph
app = supervisior_agent.compile()


print("=== AI Supervisor Agent ===")
print("Type your query (or type 'exit' to quit)\n")

while True:
    user_input = input("You: ")
    if user_input.strip().lower() in ["exit", "quit"]:
        print("Goodbye!")
        break

    input_state = {"messages": [HumanMessage(content=user_input)]}

    print("AI:")
    try:
        final_response_content = None

        # Iterate through the stream to get the final message from the END node
        for s in app.stream(input_state):
            # Print the full state at each step for detailed debugging
            # UNCOMMENT THIS FOR DEBUGGING if the problem persists:
            print(f"DEBUG STEP: {s}")

            if END in s:
                messages_at_end = s[END].get("messages", [])
                if messages_at_end:
                    last_message = messages_at_end[-1]
                    # The goal is to get the final AIMessage content
                    if isinstance(last_message, AIMessage) and last_message.content.strip():
                        final_response_content = last_message.content
                    # If for some reason the supervisor directly passes a HumanMessage (e.g. from a tool error)
                    # or a ToolMessage as the final output (less ideal for user-facing), capture it.
                    elif (isinstance(last_message, HumanMessage) or isinstance(last_message, ToolMessage)) and last_message.content.strip():
                         final_response_content = last_message.content
                break # Once END is reached, we have the final state.

        if final_response_content:
            print(final_response_content)
        else:
            # This should be very rare with the refined supervisor prompt
            print("I'm sorry, I couldn't process your request. The supervisor did not yield a final response. Please try rephrasing it or ask a different question.")

    except Exception as e:
        print(f"An unexpected error occurred while processing your query: {e}")
        import traceback
        traceback.print_exc()

    print("\n--- Ask another question ---\n")
