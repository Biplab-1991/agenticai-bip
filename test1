

# writing code for weather tool which uses a weather API
@tool
def get_current_weather(city: str, units: str = "metric") -> str:
    """
    Fetches the current weather conditions for a specified city using OpenWeatherMap.
    Returns temperature, main weather condition, and description.

    Args:
        city (str): The name of the city (e.g., "London", "New York", "Chennai").
        units (str): The unit system for temperature. 'metric' for Celsius (default),
                     'imperial' for Fahrenheit, or 'standard' for Kelvin.
    """
    base_url = "https://api.openweathermap.org/data/2.5/weather"
    params = {
        "q": city,
        "units": units,
        "appid": OPENWEATHERMAP_API_KEY
    }
    try:
        response = requests.get(base_url, params=params, timeout=10) # Added timeout
        response.raise_for_status() # Raise an HTTPError for bad responses (4xx or 5xx)
        data = response.json()

        if data.get("cod") == 200:
            main_data = data.get("main", {})
            weather_data = data.get("weather", [{}])[0]
            temp = main_data.get("temp")
            feels_like = main_data.get("feels_like")
            humidity = main_data.get("humidity")
            description = weather_data.get("description")
            main_condition = weather_data.get("main")
            city_name_from_api = data.get("name") # Use city name from API response for accuracy

            unit_symbol = "°C" if units == "metric" else ("°F" if units == "imperial" else "K")

            return (
                f"Current weather in {city_name_from_api}: "
                f"{temp}{unit_symbol} (feels like {feels_like}{unit_symbol}), "
                f"Conditions: {main_condition} - {description}, "
                f"Humidity: {humidity}%."
            )
        else:
            # More detailed error message from API if available
            return f"Error from OpenWeatherMap API for {city}: {data.get('message', 'Unknown error')} (Code: {data.get('cod')})"
    except requests.exceptions.HTTPError as e:
        status_code = e.response.status_code
        if status_code == 404:
            return f"City '{city}' not found by OpenWeatherMap. Please check the spelling."
        elif status_code == 401:
            return "OpenWeatherMap API Key is invalid or expired. Please check your key."
        else:
            return f"HTTP error from OpenWeatherMap API for {city}: {status_code} - {e.response.text}" # Include response text
    except requests.exceptions.ConnectionError as e:
        return f"Connection error to OpenWeatherMap API: {e}. Please check your internet connection."
    except requests.exceptions.Timeout as e:
        return f"Timeout error with OpenWeatherMap API: {e}. The request took too long to respond."
    except json.JSONDecodeError:
        return f"Failed to decode JSON from OpenWeatherMap API response for {city}. Response was: {response.text[:200]}..." # Show part of response
    except Exception as e:
        return f"An unexpected error occurred with OpenWeatherMap API for {city}: {type(e).__name__} - {e}"

@tool
def get_country_detail(country_name: str) -> str:
    """
    Fetches details about a country using the RapidAPI GeoDB API.
    Note: Currently supports only a limited set of countries with hardcoded codes.
    """
    headers = CaseInsensitiveDict()
    headers["x-rapidapi-host"] = "wft-geo-db.p.rapidapi.com"
    headers["x-rapidapi-key"] = RAPIDAPI_KEY

    # Expanded country code mapping for better coverage. Add more as needed.
    country_code = {
        "India": "IN",
        "United States": "US",
        "United Kingdom": "GB", # Added
        "Canada": "CA",         # Added
        "Australia": "AU",      # Added
        "Germany": "DE",        # Added
        "France": "FR",         # Added
        "Japan": "JP",          # Added
        "China": "CN",          # Added
        "Brazil": "BR",         # Added
        "South Africa": "ZA",   # Added
        "Mexico": "MX"          # Added
    }

    if country_name.lower() not in [k.lower() for k in country_code.keys()]:
        return f"Country code not available for '{country_name}'. Currently supports: {', '.join(country_code.keys())}"

    # Find the exact key from the dictionary regardless of input case
    actual_country_name = next((key for key in country_code if key.lower() == country_name.lower()), None)
    if not actual_country_name: # Should not happen with the check above, but good for safety
        return f"Internal error: Could not find country '{country_name}' in mapping."

    cntry_name_shrt_code = country_code[actual_country_name]
    url = f"https://wft-geo-db.p.rapidapi.com/v1/geo/countries/{cntry_name_shry_code}"

    print(f"DEBUG: Calling RapidAPI URL: {url}") # Use DEBUG prefix

    try:
        res = requests.get(url, headers=headers, timeout=10) # Added timeout
        res.raise_for_status() # Raise an HTTPError for bad responses (4xx or 5xx)

        data = res.json()["data"]
        callingcode = data.get("callingCode")
        currency = data["currencyCodes"][0] if data.get("currencyCodes") else "N/A" # Handle missing keys
        numberofregion = data.get("numRegions")
        flaguri = data.get("flagImageUri")

        return (f"The currency in {actual_country_name} is {currency} with calling code {callingcode}, "
                f"number of regions {numberofregion} and flag image {flaguri}")

    except requests.exceptions.HTTPError as e:
        status_code = e.response.status_code
        if status_code == 404:
            return f"Country '{actual_country_name}' not found by GeoDB API. Please check the spelling or if it's supported."
        elif status_code == 401:
            return "RapidAPI Key is invalid or expired. Please check your key."
        else:
            return f"HTTP error from RapidAPI GeoDB for {actual_country_name}: {status_code} - {e.response.text}"
    except requests.exceptions.ConnectionError as e:
        return f"Connection error to RapidAPI GeoDB: {e}. Please check your internet connection."
    except requests.exceptions.Timeout as e:
        return f"Timeout error with RapidAPI GeoDB: {e}. The request took too long to respond."
    except json.JSONDecodeError:
        return f"Failed to decode JSON from RapidAPI GeoDB API response for {actual_country_name}. Response was: {res.text[:200]}..."
    except KeyError as e:
        # More specific KeyError handling
        return f"Missing expected data in RapidAPI GeoDB response for {actual_country_name}: '{e}' key not found. Response: {res.json()}"
    except Exception as e:
        return f"An unexpected error occurred in get_country_detail for {actual_country_name}: {type(e).__name__} - {e}"


# 2. Create Worker Agents (using create_react_agent for simplicity)
# These agents will use the tools we defined
# Added explicit `return_direct=False` for agents to allow for final LLM response after tool
weather_agent_node = create_react_agent(
    model=llm,
    tools=[get_current_weather],
    prompt=ChatPromptTemplate.from_messages([
        ("system", "You are a helpful weather assistant. Always use the 'get_current_weather' tool to respond to any weather-related query. If the tool fails or cannot provide an answer, state that clearly and politely. Do not respond directly with weather information without using the tool."),
        ("human", "{messages}"),
    ]),
    name="weather_agent",
    return_direct=False # Ensure agent's final response goes through the graph for potential supervisor processing
)


country_agent_node = create_react_agent(
    model=llm,
    tools=[get_country_detail],
    prompt=ChatPromptTemplate.from_messages([
        ("system", "You are a helpful country information assistant. Always use the 'get_country_detail' tool to answer country-related queries. If the tool fails or cannot provide an answer, state that clearly and politely. Do not respond directly with country information without using the tool."),
        ("human", "{messages}"),
    ]),
    name="country_agent",
    return_direct=False # Ensure agent's final response goes through the graph
)


# 3. Create the Supervisor Workflow using create_supervisor
supervisior_agent = create_supervisor(
    agents=[weather_agent_node, country_agent_node],
    model=llm,
    prompt=(
        "You are a smart team supervisor managing a weather agent and a country information agent. "
        "Your goal is to direct user queries to the most appropriate agent or to provide a polite fallback if no agent can handle the query. "
        "When the user asks for current weather information, use the 'weather_agent'. "
        "When the user asks for country details (like currency, calling code, regions, or flag), use the 'country_agent'. "
        "If the query is ambiguous, unrelated to weather or country information, or if an agent's response indicates a failure, "
        "you should explicitly state that you cannot fulfill the request or apologize. "
        "If an agent has successfully answered the query, or if the request is not suitable for any agent and you have provided a fallback, "
        "you can signal 'FINISH'. "
        "Always prioritize routing to an agent if the query clearly matches its function. "
        "If a tool call fails and the agent passes back an error message, relay that error message to the user."
    ),
    # By default, output_mode is 'last_message', which is usually good.
    # If you need to see intermediate steps or specific agent outputs, you could change this.
    # output_mode="full_history",
)

# Compile the graph
app = supervisior_agent.compile()


print("=== AI Supervisor Agent ===")
print("Type your query (or type 'exit' to quit)\n")

while True:
    user_input = input("You: ")
    if user_input.strip().lower() in ["exit", "quit"]:
        print("Goodbye!")
        break

    input_state = {"messages": [HumanMessage(content=user_input)]}

    print("AI:")
    try:
        final_response_content = None # Initialize to None

        # Iterate through the stream to get the final message
        # The stream will typically yield an object for each node that is entered.
        # The 'END' node signifies the final state.
        for s in app.stream(input_state):
            # Print intermediate steps for debugging if needed
            # print(f"DEBUG: Current step: {s}")

            # Check if the 'END' node has been reached and it contains messages
            if END in s and "messages" in s[END] and s[END]["messages"]:
                # The last message in the 'END' state is typically the final response.
                last_message = s[END]["messages"][-1]
                if isinstance(last_message, AIMessage) and last_message.content.strip():
                    final_response_content = last_message.content
                elif isinstance(last_message, HumanMessage) and last_message.content.strip():
                    # Sometimes the supervisor might relay a human message if it's the final output
                    final_response_content = last_message.content
                elif isinstance(last_message, ToolMessage) and last_message.content.strip():
                    # If a tool message is the final output (e.g., direct tool output without LLM rephrase)
                    final_response_content = last_message.content

        if final_response_content:
            print(final_response_content)
        else:
            # Fallback for truly unexpected empty responses or if END state doesn't have a final message
            print("I'm sorry, I couldn't process your request. Please try rephrasing it or ask a different question.")

    except Exception as e:
        print(f"An unexpected error occurred while processing your query: {e}")
        # Optionally, print the full traceback for debugging:
        # import traceback
        # traceback.print_exc()

    print("\n--- Ask another question ---\n")
