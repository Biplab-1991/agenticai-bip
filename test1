from typing import Annotated, TypedDict
from langgraph.graph import StateGraph, END
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage, ToolMessage
import operator
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.tools import tool
from langgraph_supervisor import create_supervisor
from langgraph.prebuilt import create_react_agent
import requests
import json
from requests.structures import CaseInsensitiveDict
from langchain_google_genai import ChatGoogleGenerativeAI
import os

# --- API Keys (IMPORTANT: Load from environment variables) ---
RAPIDAPI_KEY = os.environ.get("RAPIDAPI_KEY")
OPENWEATHERMAP_API_KEY = os.environ.get("OPENWEATHERMAP_API_KEY")
GOOGLE_API_KEY = os.environ.get("GOOGLE_API_KEY")

if not RAPIDAPI_KEY:
    raise ValueError("RAPIDAPI_KEY environment variable not set.")
if not OPENWEATHERMAP_API_KEY:
    raise ValueError("OPENWEATHERMAP_API_KEY environment variable not set.")
if not GOOGLE_API_KEY:
    raise ValueError("GOOGLE_API_KEY environment variable not set.")


llm = ChatGoogleGenerativeAI(model="gemini-2.5-flash-preview-05-20", google_api_key=GOOGLE_API_KEY, temperature=0.2)

# 1. Define the Graph State
class AgentState(TypedDict):
    messages: Annotated[list[BaseMessage], operator.add]


# --- Tools ---
@tool
def get_current_weather(city: str, units: str = "metric") -> str:
    """
    Fetches the current weather conditions for a specified city using OpenWeatherMap.
    Returns temperature, main weather condition, and description.

    Args:
        city (str): The name of the city (e.g., "London", "New York", "Chennai").
        units (str): The unit system for temperature. 'metric' for Celsius (default),
                     'imperial' for Fahrenheit, or 'standard' for Kelvin.
    """
    base_url = "https://api.openweathermap.org/data/2.5/weather"
    params = {
        "q": city,
        "units": units,
        "appid": OPENWEATHERMAP_API_KEY
    }
    try:
        response = requests.get(base_url, params=params, timeout=10)
        response.raise_for_status()
        data = response.json()

        if data.get("cod") == 200:
            main_data = data.get("main", {})
            weather_data = data.get("weather", [{}])[0]
            temp = main_data.get("temp")
            feels_like = main_data.get("feels_like")
            humidity = main_data.get("humidity")
            description = weather_data.get("description")
            main_condition = weather_data.get("main")
            city_name_from_api = data.get("name")

            unit_symbol = "°C" if units == "metric" else ("°F" if units == "imperial" else "K")

            return (
                f"Current weather in {city_name_from_api}: "
                f"{temp}{unit_symbol} (feels like {feels_like}{unit_symbol}), "
                f"Conditions: {main_condition} - {description}, "
                f"Humidity: {humidity}%."
            )
        else:
            return f"Error from OpenWeatherMap API for {city}: {data.get('message', 'Unknown error')} (Code: {data.get('cod')})"
    except requests.exceptions.HTTPError as e:
        status_code = e.response.status_code
        if status_code == 404:
            return f"City '{city}' not found by OpenWeatherMap. Please check the spelling."
        elif status_code == 401:
            return "OpenWeatherMap API Key is invalid or expired. Please check your key."
        else:
            return f"HTTP error from OpenWeatherMap API for {city}: {status_code} - {e.response.text}"
    except requests.exceptions.ConnectionError as e:
        return f"Connection error to OpenWeatherMap API: {e}. Please check your internet connection."
    except requests.exceptions.Timeout as e:
        return f"Timeout error with OpenWeatherMap API: {e}. The request took too long to respond."
    except json.JSONDecodeError:
        return f"Failed to decode JSON from OpenWeatherMap API response for {city}. Response was: {response.text[:200]}..."
    except Exception as e:
        return f"An unexpected error occurred with OpenWeatherMap API for {city}: {type(e).__name__} - {e}"

@tool
def get_country_detail(country_name: str) -> str:
    """
    Fetches details about a country using the RapidAPI GeoDB API.
    Note: Currently supports only a limited set of countries with hardcoded codes.
    """
    headers = CaseInsensitiveDict()
    headers["x-rapidapi-host"] = "wft-geo-db.p.rapidapi.com"
    headers["x-rapidapi-key"] = RAPIDAPI_KEY

    country_code = {
        "India": "IN", "United States": "US", "United Kingdom": "GB",
        "Canada": "CA", "Australia": "AU", "Germany": "DE",
        "France": "FR", "Japan": "JP", "China": "CN",
        "Brazil": "BR", "South Africa": "ZA", "Mexico": "MX",
        "Spain": "ES", "Italy": "IT", "Russia": "RU"
    }

    actual_country_name = next((key for key in country_code if key.lower() == country_name.lower()), None)
    if not actual_country_name:
        return f"Country code not available for '{country_name}'. Currently supports: {', '.join(country_code.keys())}"

    cntry_name_shrt_code = country_code[actual_country_name]
    url = f"https://wft-geo-db.p.rapidapi.com/v1/geo/countries/{cntry_name_shrt_code}"

    try:
        res = requests.get(url, headers=headers, timeout=10)
        res.raise_for_status()

        data = res.json()["data"]
        callingcode = data.get("callingCode", "N/A")
        currency = data["currencyCodes"][0] if data.get("currencyCodes") else "N/A"
        numberofregion = data.get("numRegions", "N/A")
        flaguri = data.get("flagImageUri", "N/A")

        return (f"The currency in {actual_country_name} is {currency} with calling code {callingcode}, "
                  f"number of regions {numberofregion} and flag image {flaguri}")

    except requests.exceptions.HTTPError as e:
        status_code = e.response.status_code
        if status_code == 404:
            return f"Country '{actual_country_name}' not found by GeoDB API. Please check the spelling or if it's supported."
        elif status_code == 401:
            return "RapidAPI Key is invalid or expired. Please check your key."
        else:
            return f"HTTP error from RapidAPI GeoDB for {actual_country_name}: {status_code} - {e.response.text}"
    except requests.exceptions.ConnectionError as e:
        return f"Connection error to RapidAPI GeoDB: {e}. Please check your internet connection."
    except requests.exceptions.Timeout as e:
        return f"Timeout error with RapidAPI GeoDB: {e}. The request took too long to respond."
    except json.JSONDecodeError:
        return f"Failed to decode JSON from RapidAPI GeoDB API response for {actual_country_name}. Response was: {res.text[:200]}..."
    except KeyError as e:
        return f"Missing expected data in RapidAPI GeoDB response for {actual_country_name}: '{e}' key not found. Response: {res.json()}"
    except Exception as e:
        return f"An unexpected error occurred in get_country_detail for {actual_country_name}: {type(e).__name__} - {e}"


# 2. Create Worker Agents
weather_agent_node = create_react_agent(
    model=llm,
    tools=[get_current_weather],
    prompt=ChatPromptTemplate.from_messages([
        ("system", "You are a helpful weather assistant. Your sole purpose is to provide current weather information using the 'get_current_weather' tool. When asked about weather, use this tool. If the tool call is successful, respond with the weather information. If the tool fails or cannot find the city, clearly state that you couldn't get the weather for the specified location. Never answer questions outside of weather. If the user asks something not related to weather, respond with 'I can only provide current weather information.'"),
        ("human", "{messages}"),
    ]),
    name="weather_agent",
)


country_agent_node = create_react_agent(
    model=llm,
    tools=[get_country_detail],
    prompt=ChatPromptTemplate.from_messages([
        ("system", "You are a helpful country information assistant. Your sole purpose is to provide details about
